from __future__ import annotations
"""
OData client, production-ready
- Accepts flexible registry shapes & capitalization (Services/Entities/Fields, basePath/path)
- Case/space-insensitive lookup for service and entity names
- Auto-discovers `base_path` via $metadata if missing
- Safe auth headers, CSRF handling, retries, and proper client cleanup
- Pydantic v2-first (with v1 fallback) for response models
"""

import asyncio
import json
from pathlib import Path
from typing import Any, Dict, Optional

import httpx
from loguru import logger

from app.core.config import settings
from app.models.schemas import (
    ODataGetRequest,
    ODataPostRequest,
    ODataPreviewResponse,
    ServiceRegistryOut,
)
from app.utils.security import basic_auth_header
from app.utils.url_builder import build_entity_key_segment, build_get_url

# -----------------------------------------------------------------------------
# Constants / Paths
# -----------------------------------------------------------------------------
REGISTRY_PATH = Path(__file__).resolve().parents[1] / "data" / "registry.json"


class ODataService:
    """Builds dynamic OData URLs from a JSON registry and executes HTTP calls."""

    def __init__(self) -> None:
        self.base_url: Optional[str] = (
            settings.SAP_BASE_URL.rstrip("/") if settings.SAP_BASE_URL else None
        )
        if not self.base_url:
            raise RuntimeError("SAP_BASE_URL is not configured in .env")

        self.session: httpx.AsyncClient = httpx.AsyncClient(
            timeout=httpx.Timeout(60.0), verify=True
        )
        self._registry_cache: Optional[Dict[str, Any]] = None

    async def aclose(self) -> None:
        """Explicitly close the underlying HTTP client."""
        if not self.session.is_closed:
            await self.session.aclose()

    def __del__(self) -> None:  # best-effort cleanup
        try:
            if not self.session.is_closed:
                loop = asyncio.get_event_loop()
                if loop.is_running():
                    loop.create_task(self.session.aclose())
                else:
                    loop.run_until_complete(self.session.aclose())
        except Exception:
            pass

    # ------------------------------------------------------------------
    # Registry loading & normalization
    # ------------------------------------------------------------------
    def _load_registry(self) -> Dict[str, Any]:
        if self._registry_cache is not None:
            return self._registry_cache

        logger.info(f"Loading registry from: {REGISTRY_PATH}")
        try:
            with open(REGISTRY_PATH, "r", encoding="utf-8") as f:
                data = json.load(f)
        except FileNotFoundError as e:
            raise FileNotFoundError(
                f"Registry file not found at {REGISTRY_PATH}."
            ) from e
        except json.JSONDecodeError as e:
            raise ValueError(
                f"Registry file at {REGISTRY_PATH} is not valid JSON."
            ) from e

        self._normalize_registry_inplace(data)
        self._registry_cache = data
        return data

    def _normalize_registry_inplace(self, reg: dict) -> None:
        """Normalize capitalization/variants so code can assume canonical keys.
        - Top-level: Services/services → services (read case-insensitively)
        - Per-service: basePath/path → base_path
        - Per-service: Entities/entities → entities
        - Per-entity: Fields/fields → fields; ensure key_fields exists
        """
        services = self._get_services_mapping(reg)
        if not isinstance(services, dict):
            return

        for _sname, sdef in services.items():
            if not isinstance(sdef, dict):
                continue

            # base_path variants (non-destructive if missing)
            if "base_path" not in sdef:
                for k, v in sdef.items():
                    if isinstance(k, str) and k.lower() in {"basepath", "path"}:
                        sdef["base_path"] = v
                        break

            # entities mapping (case-insensitive)
            entities = self._get_entities_mapping(sdef)
            if not isinstance(entities, dict):
                continue

            for _ename, edef in entities.items():
                if not isinstance(edef, dict):
                    continue

                # fields
                if "fields" not in edef:
                    for k, v in edef.items():
                        if isinstance(k, str) and k.lower() == "fields":
                            edef["fields"] = v
                            break

                # key_fields (accept keyFields, key_fields, Key_fields, etc.)
                if "key_fields" not in edef:
                    for k, v in edef.items():
                        if isinstance(k, str) and k.lower() in {"key_fields", "keyfields"}:
                            edef["key_fields"] = v
                            break

                edef.setdefault("fields", [])
                edef.setdefault("key_fields", [])

    # ------------------------------------------------------------------
    # Case-insensitive service/entity helpers
    # ------------------------------------------------------------------
    def _get_services_mapping(self, registry: dict) -> Dict[str, Any]:
        for k, v in registry.items():
            if isinstance(k, str) and k.lower() == "services":
                return v if isinstance(v, dict) else {}
        return registry if isinstance(registry, dict) else {}

    def _get_entities_mapping(self, service_def: dict) -> Dict[str, Any]:
        for k, v in service_def.items():
            if isinstance(k, str) and k.lower() == "entities":
                return v if isinstance(v, dict) else {}
        return {}

    def _find_service(self, services: Dict[str, Any], name: str) -> Optional[Dict[str, Any]]:
        target = (name or "").strip().lower()
        for k, v in services.items():
            if isinstance(k, str) and k.strip().lower() == target:
                return v
        return None

    def _find_entity(self, svc: Dict[str, Any], entity_name: str) -> Optional[Dict[str, Any]]:
        entities = self._get_entities_mapping(svc)
        target = (entity_name or "").strip().lower()
        for k, v in entities.items():
            if isinstance(k, str) and k.strip().lower() == target:
                return v
        return None

    # ------------------------------------------------------------------
    # Auth & CSRF helpers
    # ------------------------------------------------------------------
    def _auth_headers(self) -> Dict[str, str]:
        mode = (settings.SAP_AUTH_MODE or "basic").lower()
        if mode == "basic":
            return {
                "Authorization": basic_auth_header(
                    settings.SAP_USERNAME, settings.SAP_PASSWORD
                )
            }
        if mode == "oauth2":
            token = getattr(settings, "SAP_OAUTH_TOKEN", None)
            if not token:
                raise RuntimeError(
                    "SAP_AUTH_MODE is 'oauth2' but SAP_OAUTH_TOKEN is not configured."
                )
            return {"Authorization": f"Bearer {token}"}
        return {}

    async def _fetch_csrf(self, url_path: str) -> Dict[str, Any]:
        """Fetch CSRF token and cookies for a given service path (NOT full URL)."""
        headers = {**self._auth_headers(), "X-CSRF-Token": "Fetch", "Accept": "application/json"}
        url = f"{self.base_url}/{url_path.lstrip('/')}"
        resp = await self.session.get(url, headers=headers)
        resp.raise_for_status()
        token = resp.headers.get("x-csrf-token") or resp.headers.get("X-CSRF-Token")
        if not token:
            logger.warning("CSRF token missing in response headers; check SAP config.")
        return {"token": token, "cookies": resp.cookies}

    # ------------------------------------------------------------------
    # Base path discovery (for registries without base_path)
    # ------------------------------------------------------------------
    async def _discover_base_path(self, service_name: str) -> Optional[str]:
        """Probe common SAP OData roots until $metadata responds 2xx."""
        candidates = [
            f"/sap/opu/odata/sap/{service_name}",
            f"/sap/opu/odata4/sap/{service_name}",
            f"/{service_name}",
        ]
        headers = {**self._auth_headers(), "Accept": "application/xml"}
        for path in candidates:
            url = f"{self.base_url}/{path.lstrip('/')}/$metadata"
            try:
                r = await self.session.get(url, headers=headers)
                if 200 <= r.status_code < 300:
                    logger.info(f"Discovered base_path for {service_name}: {path}")
                    return path
            except Exception:
                pass
        return None

    async def _get_base_path_async(self, svc: Dict[str, Any], service_name: str) -> str:
        base_path = svc.get("base_path") or svc.get("basePath") or svc.get("path")
        if base_path:
            return str(base_path)
        discovered = await self._discover_base_path(service_name)
        if discovered:
            svc["base_path"] = discovered  # cache in-memory for subsequent calls
            return discovered
        raise ValueError(
            f"Registry for service '{service_name}' lacks base_path and auto-discovery failed. "
            f"Keys present: {list(svc.keys())}"
        )

    # ------------------------------------------------------------------
    # GET
    # ------------------------------------------------------------------
    async def execute_get(self, req: ODataGetRequest):
        registry = self._load_registry()
        services = self._get_services_mapping(registry)
        svc = self._find_service(services, req.service)
        if not svc:
            logger.error("Service not found. requested=%r available=%r", req.service, list(services.keys()))
            raise ValueError(f"Service '{req.service}' not found in registry")

        entity_def = self._find_entity(svc, req.entity)
        if not entity_def:
            entities = self._get_entities_mapping(svc)
            logger.error("Entity not found. requested=%r available=%r", req.entity, list(entities.keys()))
            raise ValueError(f"Entity '{req.entity}' not found in service '{req.service}'")

        base_path = await self._get_base_path_async(svc, req.service)
        url = build_get_url(
            base_url=self.base_url,
            base_path=base_path,
            entity=req.entity,
            fields=req.fields,
            filters=[
                f.model_dump() if hasattr(f, "model_dump") else f for f in (req.filters or [])
            ],
            top=req.top,
            skip=req.skip,
            orderby=req.orderby,
        )
        headers = {**self._auth_headers(), "Accept": "application/json"}
        logger.info(f"GET -> {url}")
        r = await self._request_with_retry("GET", url, headers=headers)
        r.raise_for_status()
        return r.json() if r.content else {"status_code": r.status_code}

    # ------------------------------------------------------------------
    # POST (create/update)
    # ------------------------------------------------------------------
    async def preview_post(self, req: ODataPostRequest) -> ODataPreviewResponse:
        svc_path, url, method, payload = await self._compose_post(req)
        headers_preview = {"Accept": "application/json", "Content-Type": "application/json"}
        return ODataPreviewResponse(ok=True, url=url, method=method, headers_preview=headers_preview, payload=payload)

    async def execute_post(self, req: ODataPostRequest):
        svc_path, url, method, payload = await self._compose_post(req)
        csrf = await self._fetch_csrf(svc_path)
        headers: Dict[str, str] = {
            **self._auth_headers(),
            "Accept": "application/json",
            "Content-Type": "application/json",
        }
        if csrf.get("token"):
            headers["X-CSRF-Token"] = csrf["token"]

        logger.info(f"{method} -> {url} (payload keys: {list((payload or {}).keys())})")
        r = await self._request_with_retry(method, url, headers=headers, json=payload, cookies=csrf.get("cookies"))
        if r.status_code == 204 or not r.content:
            return {"status_code": r.status_code}
        try:
            return r.json()
        except ValueError:
            return {"status_code": r.status_code, "text": r.text}

    async def _compose_post(self, req: ODataPostRequest):
        if req.action not in ("create", "update"):
            raise ValueError("action must be 'create' or 'update'")

        registry = self._load_registry()
        services = self._get_services_mapping(registry)
        svc = self._find_service(services, req.service)
        if not svc:
            logger.error("Service not found. requested=%r available=%r", req.service, list(services.keys()))
            raise ValueError(f"Service '{req.service}' not found in registry")

        entity_def = self._find_entity(svc, req.entity)
        if not entity_def:
            entities = self._get_entities_mapping(svc)
            logger.error("Entity not found. requested=%r available=%r", req.entity, list(entities.keys()))
            raise ValueError(f"Entity '{req.entity}' not found in service '{req.service}'")

        base_path = await self._get_base_path_async(svc, req.service)
        if req.action == "create" or not req.key_fields:
            url_path = f"{base_path.rstrip('/')}/{req.entity}"
            method = "POST"
        else:
            key_seg = build_entity_key_segment(req.key_fields)
            url_path = f"{base_path.rstrip('/')}/{req.entity}{key_seg}"
            method = "PATCH"

        url = f"{self.base_url}/{url_path.lstrip('/')}"
        payload = req.payload
        return base_path, url, method, payload

    # ------------------------------------------------------------------
    # Retry wrapper
    # ------------------------------------------------------------------
    async def _request_with_retry(self, method: str, url: str, **kwargs) -> httpx.Response:
        max_attempts = 3
        base_delay = 0.75
        last_exc: Optional[BaseException] = None

        for attempt in range(1, max_attempts + 1):
            try:
                r = await self.session.request(method, url, **kwargs)
                # retry on transient statuses
                if r.status_code in {429, 502, 503, 504}:
                    raise httpx.HTTPStatusError(
                        f"transient status {r.status_code}", request=r.request, response=r
                    )
                return r
            except Exception as e:
                last_exc = e
                logger.warning(
                    f"Attempt {attempt}/{max_attempts} failed for {method} {url}: {e}"
                )
                if attempt < max_attempts:
                    await asyncio.sleep(base_delay * attempt)

        logger.error(f"All attempts failed for {method} {url}")
        if last_exc:
            raise last_exc
        raise RuntimeError("request failed without exception")
