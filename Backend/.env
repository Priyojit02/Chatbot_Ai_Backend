from __future__ import annotations

import asyncio
from typing import Any, Dict, Optional
from urllib.parse import urlencode

import httpx
from loguru import logger

from app.core.config import settings  # ✅ correct import


# -----------------------------
# Tunables
# -----------------------------
POST_REQUIRE_KEY_IN_URL = False                      # POST /EntitySet  (False)  vs  POST /EntitySet('key') (True)
POST_KEY_FIELD_NAME: str | None = "PLANT"            # When not using key in URL, inject the key into payload under this field (if provided)

CSRF_FETCH_FROM = "service"                          # "service" (preferred) | "entityset"
S_CLIENT_PARAM = "sap-client"
INCLUDE_CLIENT_ON_CSRF = True

RETRY_ON_403_CSRF = True
RETURN_WRAPPED = True

RETRY_ATTEMPTS = 3
RETRY_BASE_DELAY_SEC = 0.75

USE_MERGE_FOR_PATCH = True

DEFAULT_HEADERS: Dict[str, str] = {
    "Accept": "application/json",
    "Content-Type": "application/json",
    "SAP-ContextId-Accept": "header",
    "X-Requested-With": "XMLHttpRequest",   # important for many gateways
}


# -------------------------------------------------
# URL helpers (assumes SAP_BASE_URL ends with .../sap/opu/odata/SAP)
# -------------------------------------------------
def _base() -> str:
    if not settings.SAP_BASE_URL:
        raise RuntimeError("SAP_BASE_URL is not configured in .env")
    return settings.SAP_BASE_URL.rstrip("/")


def _svc(service_name: str) -> str:
    if not service_name:
        raise ValueError("service_name is required")
    return service_name.strip("/").split("/")[-1]


def _qs() -> str:
    params = {}
    if getattr(settings, "SAP_CLIENT", None):
        params[S_CLIENT_PARAM] = settings.SAP_CLIENT
    return f"?{urlencode(params)}" if params else ""


def _service_root_url(service_name: str) -> str:
    url = f"{_base()}/{_svc(service_name)}/"
    return url + _qs() if INCLUDE_CLIENT_ON_CSRF else url


def _entityset_url(service_name: str, entity_set: str) -> str:
    if not entity_set:
        raise ValueError("entity_set is required")
    url = f"{_base()}/{_svc(service_name)}/{entity_set}{_qs()}"
    logger.debug(f"[OData] EntitySet URL: {url}")
    return url


def _entity_url(service_name: str, entity_set: str, key_value: Optional[str]) -> str:
    if not entity_set:
        raise ValueError("entity_set is required")
    if key_value:
        url = f"{_base()}/{_svc(service_name)}/{entity_set}('{key_value}'){_qs()}"
    else:
        url = f"{_base()}/{_svc(service_name)}/{entity_set}{_qs()}"
    logger.debug(f"[OData] Entity URL: {url}")
    return url


# -------------------------------------------------
# Auth & CSRF
# -------------------------------------------------
def _auth_headers() -> Dict[str, str]:
    mode = (getattr(settings, "SAP_AUTH_MODE", "basic") or "basic").lower()
    if mode == "basic":
        user = getattr(settings, "SAP_USERNAME", None)
        pw = getattr(settings, "SAP_PASSWORD", None)
        if not user:
            raise RuntimeError("SAP_AUTH_MODE=basic but SAP_USERNAME is missing")
        import base64
        token = base64.b64encode(f"{user}:{pw or ''}".encode("utf-8")).decode("ascii")
        return {"Authorization": f"Basic {token}"}
    if mode == "oauth2":
        tok = getattr(settings, "SAP_OAUTH_TOKEN", None)
        if not tok:
            raise RuntimeError("SAP_AUTH_MODE=oauth2 but SAP_OAUTH_TOKEN is missing")
        return {"Authorization": f"Bearer {tok}"}
    return {}  # no auth


async def _fetch_csrf_once(
    client: httpx.AsyncClient,
    service_name: str,
    entity_set: Optional[str],
    from_where: str,
) -> Optional[str]:
    if from_where == "service":
        probe = _service_root_url(service_name)
    else:
        if not entity_set:
            return None
        probe = _entityset_url(service_name, entity_set)

    headers = {
        **_auth_headers(),
        "X-CSRF-Token": "Fetch",
        "Accept": "application/json",
        "X-Requested-With": "XMLHttpRequest",
    }
    logger.info(f"[OData] CSRF GET {probe}")
    r = await client.get(probe, headers=headers)
    r.raise_for_status()
    token = r.headers.get("x-csrf-token") or r.headers.get("X-CSRF-Token")
    if not token:
        logger.warning("CSRF token not returned; check SAP config/policy.")
    return token


async def _fetch_csrf(client: httpx.AsyncClient, service_name: str, entity_set: str) -> str:
    token = await _fetch_csrf_once(client, service_name, entity_set, CSRF_FETCH_FROM)
    if token:
        return token
    other = "entityset" if CSRF_FETCH_FROM == "service" else "service"
    logger.info(f"[OData] CSRF fallback -> trying {other}")
    token = await _fetch_csrf_once(client, service_name, entity_set, other)
    return token or ""


# -------------------------------------------------
# Shaping hooks
# -------------------------------------------------
def shape_outgoing_payload(payload: Dict[str, Any]) -> Dict[str, Any]:
    # Filter out None to keep the body clean
    return {k: v for k, v in (payload or {}).items() if v is not None}


def shape_incoming_response(data: Any) -> Any:
    if not RETURN_WRAPPED:
        return data
    return {"ok": True, "data": data}


def shape_error_response(exc: Exception) -> Any:
    if not RETURN_WRAPPED:
        raise
    return {"ok": False, "error": str(exc)}


# -------------------------------------------------
# Retry wrapper
# -------------------------------------------------
async def _request_with_retry(client: httpx.AsyncClient, method: str, url: str, **kwargs) -> httpx.Response:
    last_exc: Optional[BaseException] = None
    for attempt in range(1, RETRY_ATTEMPTS + 1):
        try:
            r = await client.request(method, url, **kwargs)
            if r.status_code in {429, 502, 503, 504}:
                raise httpx.HTTPStatusError(
                    f"transient {r.status_code}", request=r.request, response=r
                )
            return r
        except Exception as e:
            last_exc = e
            logger.warning(f"[OData] Attempt {attempt}/{RETRY_ATTEMPTS} failed for {method} {url}: {e}")
            if attempt < RETRY_ATTEMPTS:
                await asyncio.sleep(RETRY_BASE_DELAY_SEC * attempt)
    if last_exc:
        raise last_exc
    raise RuntimeError("request failed (no exception)")


# -------------------------------------------------
# Single write with CSRF retry
# -------------------------------------------------
async def _write_with_csrf_retry(
    client: httpx.AsyncClient,
    method: str,
    url: str,
    headers: Dict[str, str],
    json_payload: Optional[Dict[str, Any]],
    service_name: str,
    entity_set: str,
) -> httpx.Response:
    r = await _request_with_retry(client, method, url, headers=headers, json=json_payload)
    if RETRY_ON_403_CSRF and r.status_code == 403:
        need = r.headers.get("x-csrf-token") or r.headers.get("X-CSRF-Token")
        if need and need.lower() == "required":
            logger.warning("[OData] 403 with x-csrf-token: Required — refetching CSRF and retrying once")
            new_token = await _fetch_csrf(client, service_name, entity_set)
            if new_token:
                headers = dict(headers)
                headers["X-CSRF-Token"] = new_token
                r = await _request_with_retry(client, method, url, headers=headers, json=json_payload)
    return r


# -------------------------------------------------
# Public client
# -------------------------------------------------
class SAPClient:
    """
    await SAPClient.call(service, entity_set, key_value, payload, method)

    Behavior:
    - GET from EntitySet root
    - POST to EntitySet (no key in URL) unless POST_REQUIRE_KEY_IN_URL = True
    - PATCH/MERGE to EntitySet('key')  (adds `If-Match: *` by default)
    - CSRF fetched from service root (fallback to entityset)
    - One-time CSRF retry on "Required"
    - Retries on 429/5xx
    """

    @staticmethod
    async def call(
        service_name: str,
        entity_set: str,
        key_value: Optional[str],
        payload: Dict[str, Any],
        method: str,
    ) -> Any:
        m = (method or "GET").upper()

        entityset_url = _entityset_url(service_name, entity_set)
        entity_url = _entity_url(service_name, entity_set, key_value)

        async with httpx.AsyncClient(timeout=60.0, follow_redirects=True) as client:
            try:
                if m == "GET":
                    headers = {**_auth_headers(), **DEFAULT_HEADERS}
                    logger.info(f"[OData] GET {entityset_url}")
                    r = await _request_with_retry(client, "GET", entityset_url, headers=headers)
                    r.raise_for_status()
                    data = r.json() if r.content else {"status": r.status_code}
                    return shape_incoming_response(data)

                # Writes → CSRF
                token = await _fetch_csrf(client, service_name, entity_set)
                headers = {**_auth_headers(), **DEFAULT_HEADERS}
                if token:
                    headers["X-CSRF-Token"] = token
                # Updates typically require If-Match. Use wildcard for convenience.
                headers.setdefault("If-Match", "*")

                outgoing = shape_outgoing_payload(payload or {})

                if m == "POST":
                    if POST_REQUIRE_KEY_IN_URL:
                        if not key_value:
                            raise ValueError("POST requires key_value (POST_REQUIRE_KEY_IN_URL=True).")
                        url_for_write = entity_url
                    else:
                        url_for_write = entityset_url
                        # Optionally inject key into payload if caller provided it
                        if key_value and POST_KEY_FIELD_NAME and POST_KEY_FIELD_NAME not in outgoing:
                            outgoing[POST_KEY_FIELD_NAME] = key_value

                    logger.info(f"[OData] POST {url_for_write} (payload keys: {list(outgoing.keys())})")
                    r = await _write_with_csrf_retry(
                        client, "POST", url_for_write, headers, outgoing, service_name, entity_set
                    )

                elif m in ("PATCH", "MERGE"):
                    if not key_value:
                        raise ValueError("PATCH/MERGE requires key_value")

                    url_for_write = entity_url
                    if m == "PATCH" and USE_MERGE_FOR_PATCH:
                        # Some Gateways prefer MERGE via POST + X-HTTP-Method
                        hdrs = {**headers, "X-HTTP-Method": "MERGE"}
                        logger.info(f"[OData] MERGE (via POST) {url_for_write} (payload keys: {list(outgoing.keys())})")
                        r = await _write_with_csrf_retry(
                            client, "POST", url_for_write, hdrs, outgoing, service_name, entity_set
                        )
                    else:
                        meth = "PATCH" if m == "PATCH" else "MERGE"
                        logger.info(f"[OData] {meth} {url_for_write} (payload keys: {list(outgoing.keys())})")
                        r = await _write_with_csrf_retry(
                            client, meth, url_for_write, headers, outgoing, service_name, entity_set
                        )

                elif m == "DELETE":
                    if not key_value:
                        raise ValueError("DELETE requires key_value")
                    url_for_write = entity_url
                    logger.info(f"[OData] DELETE {url_for_write}")
                    r = await _write_with_csrf_retry(
                        client, "DELETE", url_for_write, headers, None, service_name, entity_set
                    )

                else:
                    # Fallback unknown → simple GET
                    headers = {**_auth_headers(), **DEFAULT_HEADERS}
                    logger.info(f"[OData] GET {entityset_url}")
                    r = await _request_with_retry(client, "GET", entityset_url, headers=headers)

                r.raise_for_status()
                if r.status_code == 204 or not r.content:
                    return shape_incoming_response({"status": "OK", "http_status": r.status_code})
                return shape_incoming_response(r.json())

            except httpx.HTTPStatusError as e:
                resp = e.response
                err_payload = {
                    "ok": False,
                    "status": resp.status_code if resp else None,
                    "url": str(resp.request.url) if resp and resp.request else None,
                    "body": resp.text[:2000] if resp and resp.text else None,
                    "headers": dict(resp.headers) if resp else None,
                }
                logger.error(f"[OData] HTTP error: {err_payload}")
                return err_payload

            except Exception as e:
                logger.error(f"[OData] call failed: {e}")
                return shape_error_response(e)
